{
  "version": 3,
  "sources": [
    "../node_modules/browser-pack/_prelude.js",
    "../lib/ono.js",
    "../node_modules/format-util/format.js"
  ],
  "names": [],
  "mappings": ";;;;;;;;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nvar format = require('format-util');\nvar slice = Array.prototype.slice;\nvar protectedProperties = ['name', 'message', 'stack'];\nvar errorPrototypeProperties = [\n  'name', 'message', 'description', 'number', 'code', 'fileName', 'lineNumber', 'columnNumber',\n  'sourceURL', 'line', 'column', 'stack'\n];\n\nmodule.exports = create(Error);\nmodule.exports.error = create(Error);\nmodule.exports.eval = create(EvalError);\nmodule.exports.range = create(RangeError);\nmodule.exports.reference = create(ReferenceError);\nmodule.exports.syntax = create(SyntaxError);\nmodule.exports.type = create(TypeError);\nmodule.exports.uri = create(URIError);\nmodule.exports.formatter = format;\n\n/**\n * Creates a new {@link ono} function that creates the given Error class.\n *\n * @param {Class} Klass - The Error subclass to create\n * @returns {ono}\n */\nfunction create (Klass) {\n  /**\n   * @param {Error}   [err]     - The original error, if any\n   * @param {object}  [props]   - An object whose properties will be added to the error object\n   * @param {string}  [message] - The error message. May contain {@link util#format} placeholders\n   * @param {...*}    [params]  - Parameters that map to the `message` placeholders\n   * @returns {Error}\n   */\n  return function onoFactory (err, props, message, params) {   // eslint-disable-line no-unused-vars\n    var formatArgs = [];\n    var formattedMessage = '';\n\n    // Determine which arguments were actually specified\n    if (typeof err === 'string') {\n      formatArgs = slice.call(arguments);\n      err = props = undefined;\n    }\n    else if (typeof props === 'string') {\n      formatArgs = slice.call(arguments, 1);\n      props = undefined;\n    }\n    else if (typeof message === 'string') {\n      formatArgs = slice.call(arguments, 2);\n    }\n\n    // If there are any format arguments, then format the error message\n    if (formatArgs.length > 0) {\n      formattedMessage = module.exports.formatter.apply(null, formatArgs);\n    }\n\n    if (err && err.message) {\n      // The inner-error's message will be added to the new message\n      formattedMessage += (formattedMessage ? ' \\n' : '') + err.message;\n    }\n\n    // Create the new error\n    // NOTE: DON'T move this to a separate function! We don't want to pollute the stack trace\n    var newError = new Klass(formattedMessage);\n\n    // Extend the new error with the additional properties\n    extendError(newError, err);   // Copy properties of the original error\n    extendToJSON(newError);       // Replace the original toJSON method\n    extend(newError, props);      // Copy custom properties, possibly including a custom toJSON method\n\n    return newError;\n  };\n}\n\n/**\n * Extends the targetError with the properties of the source error.\n *\n * @param {Error}   targetError - The error object to extend\n * @param {?Error}  sourceError - The source error object, if any\n */\nfunction extendError (targetError, sourceError) {\n  extendStack(targetError, sourceError);\n  extend(targetError, sourceError);\n}\n\n/**\n * JavaScript engines differ in how errors are serialized to JSON - especially when it comes\n * to custom error properties and stack traces.  So we add our own toJSON method that ALWAYS\n * outputs every property of the error.\n */\nfunction extendToJSON (error) {\n  error.toJSON = errorToJSON;\n\n  // Also add an inspect() method, for compatibility with Node.js' `util.inspect()` method\n  error.inspect = errorToString;\n}\n\n/**\n * Extends the target object with the properties of the source object.\n *\n * @param {object}  target - The object to extend\n * @param {?source} source - The object whose properties are copied\n */\nfunction extend (target, source) {\n  if (source && typeof source === 'object') {\n    var keys = Object.keys(source);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      // Don't copy \"protected\" properties, since they have special meaning/behavior\n      // and are set by the onoFactory function\n      if (protectedProperties.indexOf(key) >= 0) {\n        continue;\n      }\n\n      try {\n        target[key] = source[key];\n      }\n      catch (e) {\n        // This property is read-only, so it can't be copied\n      }\n    }\n  }\n}\n\n/**\n * Custom JSON serializer for Error objects.\n * Returns all built-in error properties, as well as extended properties.\n *\n * @returns {object}\n */\nfunction errorToJSON () {\n  var json = {};\n\n  // Get all the properties of this error\n  var keys = Object.keys(this);\n\n  // Also include properties from the Error prototype\n  keys = keys.concat(errorPrototypeProperties);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = this[key];\n    var type = typeof value;\n    if (type !== 'undefined' && type !== 'function') {\n      json[key] = value;\n    }\n  }\n\n  return json;\n}\n\n/**\n * Serializes Error objects as human-readable JSON strings for debugging/logging purposes.\n *\n * @returns {string}\n */\nfunction errorToString () {\n  return JSON.stringify(this, null, 2).replace(/\\\\n/g, '\\n');\n}\n\n/**\n * Extend the error stack to include its cause\n *\n * @param {Error} targetError\n * @param {Error} sourceError\n */\nfunction extendStack (targetError, sourceError) {\n  if (hasLazyStack(targetError)) {\n    if (sourceError) {\n      lazyJoinStacks(targetError, sourceError);\n    }\n    else {\n      lazyPopStack(targetError);\n    }\n  }\n  else {\n    if (sourceError) {\n      targetError.stack = joinStacks(targetError.stack, sourceError.stack);\n    }\n    else {\n      targetError.stack = popStack(targetError.stack);\n    }\n  }\n}\n\n/**\n * Appends the original {@link Error#stack} property to the new Error's stack.\n *\n * @param {string} newStack\n * @param {string} originalStack\n * @returns {string}\n */\nfunction joinStacks (newStack, originalStack) {\n  newStack = popStack(newStack);\n\n  if (newStack && originalStack) {\n    return newStack + '\\n\\n' + originalStack;\n  }\n  else {\n    return newStack || originalStack;\n  }\n}\n\n/**\n * Removes Ono from the stack, so that the stack starts at the original error location\n *\n * @param {string} stack\n * @returns {string}\n */\nfunction popStack (stack) {\n  if (stack) {\n    var lines = stack.split('\\n');\n\n    if (lines.length < 2) {\n      // The stack only has one line, so there's nothing we can remove\n      return stack;\n    }\n\n    // Find the `onoFactory` call in the stack, and remove it\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i];\n      if (line.indexOf('onoFactory') >= 0) {\n        lines.splice(i, 1);\n        return lines.join('\\n');\n      }\n    }\n\n    // If we get here, then the stack doesn't contain a call to `onoFactory`.\n    // This may be due to minification or some optimization of the JS engine.\n    // So just return the stack as-is.\n    return stack;\n  }\n}\n\n/**\n * Does a one-time determination of whether this JavaScript engine\n * supports lazy `Error.stack` properties.\n */\nvar supportsLazyStack = (function () {\n  return !!(\n    // ES5 property descriptors must be supported\n    Object.getOwnPropertyDescriptor && Object.defineProperty &&\n\n    // Chrome on Android doesn't support lazy stacks :(\n    (typeof navigator === 'undefined' || !/Android/.test(navigator.userAgent))\n  );\n}());\n\n/**\n * Does this error have a lazy stack property?\n *\n * @param {Error} err\n * @returns {boolean}\n */\nfunction hasLazyStack (err) {\n  if (!supportsLazyStack) {\n    return false;\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(err, 'stack');\n  if (!descriptor) {\n    return false;\n  }\n  return typeof descriptor.get === 'function';\n}\n\n/**\n * Calls {@link joinStacks} lazily, when the {@link Error#stack} property is accessed.\n *\n * @param {Error} targetError\n * @param {Error} sourceError\n */\nfunction lazyJoinStacks (targetError, sourceError) {\n  var targetStack = Object.getOwnPropertyDescriptor(targetError, 'stack');\n\n  Object.defineProperty(targetError, 'stack', {\n    get: function () {\n      return joinStacks(targetStack.get.apply(targetError), sourceError.stack);\n    },\n    enumerable: false,\n    configurable: true\n  });\n}\n\n/**\n * Calls {@link popStack} lazily, when the {@link Error#stack} property is accessed.\n *\n * @param {Error} error\n */\nfunction lazyPopStack (error) {\n  var targetStack = Object.getOwnPropertyDescriptor(error, 'stack');\n\n  Object.defineProperty(error, 'stack', {\n    get: function () {\n      return popStack(targetStack.get.apply(error));\n    },\n    enumerable: false,\n    configurable: true\n  });\n}\n",
    "function format(fmt) {\n  var re = /(%?)(%([jds]))/g\n    , args = Array.prototype.slice.call(arguments, 1);\n  if(args.length) {\n    fmt = fmt.replace(re, function(match, escaped, ptn, flag) {\n      var arg = args.shift();\n      switch(flag) {\n        case 's':\n          arg = '' + arg;\n          break;\n        case 'd':\n          arg = Number(arg);\n          break;\n        case 'j':\n          arg = JSON.stringify(arg);\n          break;\n      }\n      if(!escaped) {\n        return arg; \n      }\n      args.unshift(arg);\n      return match;\n    })\n  }\n\n  // arguments remain after formatting\n  if(args.length) {\n    fmt += ' ' + args.join(' ');\n  }\n\n  // update escaped %% values\n  fmt = fmt.replace(/%{2,2}/g, '%');\n\n  return '' + fmt;\n}\n\nmodule.exports = format;\n"
  ]
}